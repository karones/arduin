#define API "1.0.1"

unsigned int messageCount = 1; //todo изменить тип или сделать обработку при переполнении.
bool Status = false;  //0 free 1 work
String inputString = "";
struct axisStruct  //todo шаблон
{
  int index;
  int maxValue;
  int minValue;
};
typedef struct axisStruct axisStruct;
#define COUNT_AXIS 5
axisStruct axisData[COUNT_AXIS]; //пока вручную, заполняется в функции //

void setup() {

  inputString.reserve(200);
  Serial.begin(9600);

}

void loop() {
  // put your main code here, to run repeatedly:

}

void moduleConnect(String mData)
{
  if (mData.lastIndexOf(String (API)))
    mData = "answer:accepted" + String(API);
  else
    mData = "answer:error";
  CreateMessage(mData);
}

void moduleCapalities()
{
  //todo сделать генерацию списка
  String function = "function@1@move@num@num,axis@1@STRAIGHT@100@-100";
  function = ":" + function;
  function = String (API) + function;
  function = ":" + function;
  function = "answer:accepted" + function;
  CreateMessage(function);
}
int LengthInt(int i)
{
  int count = 0;
  while (i / 10 != 0)
    count ++;
  return count;
}

void CreateMessage(String message)
{

  //message = "RCML:";
  message = + "&&";
  message = ":" + message;
  message = String(messageCount) + message;
  unsigned int length = message.length();
  if (LengthInt(length) == LengthInt(length + LengthInt (length)))
    length = + LengthInt(length);
  else
    length = + LengthInt(length) + 1;
  message = String(length) + message;
  message = "RCML:" + message;
  messageCount ++;
  Serial.print(message);
  return;
}
void moduleRequre(unsigned int mCount)
{
  if (!Status)
  {
    Status = true;
    CreateMessage("answer:accepted");
  }
  else
  {
    if(mCount == messageCount)
    CreateMessage("answer:error:required_by_this");
    else
     CreateMessage("answer:error:required_by_another");
   }
  return;
}

void freeRobot()
{
  Status = false;
  return;
}

void moduleFree(unsigned int mCount)
{
  if (Status)
  {
     if(mCount == messageCount)
     {
      freeRobot();
      CreateMessage("answer:accepted");
     }
     else
     CreateMessage("answer:error:required_by_another");
  }
  else
  {
     CreateMessage("answer:error:already_freed");
  }
}

void setAxis(int index, int value)
{
//  Serial.println("axis ", index,  "state value ", value);
  return;
}
 void moduleAxis(String mMessage)
 {
  int index, value;
  String mData = mMessage.substring((mMessage.indexOf(':', mMessage.indexOf(":") + 1 )), (mMessage.indexOf(':', mMessage.indexOf(":") + 2 )));
  index = mData.toInt();
  mData = mMessage.substring((mMessage.indexOf(':', mMessage.indexOf(":") + 2 )), (mMessage.indexOf(':', mMessage.indexOf(":") + 3 )));
  value = mData.toInt();
    for (int i=0; i<COUNT_AXIS; i++)
    {
      if (axisData[i].index == index)
      {
        if (axisData[i].minValue < value < axisData[i].maxValue)
        {
          setAxis(index, value);
          return;
        }
        else
        {
         CreateMessage("answer:error:axis_value");
          return;
        }
      }
    }
    CreateMessage("answer:error:axis_index");
    return;
 }

void moduleExecute(String mData)
{
  
  Serial.println("execute function");
  String index = inputString.substring(inputString.indexOf(":"), (inputString.indexOf(':', inputString.indexOf(":") + 1 )));
  int indexFunction= index.toInt();
  switch(indexFunction)
  {
case 5:
    {
      //bla bla bla
      break;
    }
    default:
    CreateMessage("answer:error:function_index");
  }
  messageCount++;
  return;
}

void serialEvent() {
  while (Serial.available()) {
    // get the new byte:
    char inChar = (char)Serial.read();
    // add it to the inputString:
    inputString += inChar;
    // if the incoming character is a newline, set a flag
    // so the main loop can do something about it:
    if (inChar == '\n') {
      String mData = inputString.substring(inputString.indexOf(":"), (inputString.indexOf(':', inputString.indexOf(":") + 1 )));
      unsigned int length = mData.toInt();
      if (length != 0) {
        mData = inputString.substring((inputString.indexOf(':', inputString.indexOf(":") + 1 )), (inputString.indexOf(':', inputString.indexOf(":") + 2 )));
        unsigned int mCount = mData.toInt();
        if (mCount != messageCount)
        {
          Serial.print("error");
        }
        mData = inputString.substring(inputString.indexOf(":"), inputString.indexOf("&&"));
        if (mData.lastIndexOf("connect"))
          moduleConnect(mData);
          if (mData.lastIndexOf("require"))
          moduleRequre(mCount);
        if (mData.lastIndexOf("robot_capabilites"))
          moduleCapalities();
        if (mData.lastIndexOf("execute"))
          moduleExecute(mData);
             if (mData.lastIndexOf("axis"))
          moduleExecute(mData);
        if (mData.lastIndexOf("free"))
          moduleFree(mCount);

      }



    }
  }

}
